<?php
/**
 * Destiny2Api
 * PHP version 5
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bungie\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bungie\ApiException;
use Bungie\Configuration;
use Bungie\HeaderSelector;
use Bungie\ObjectSerializer;

/**
 * Destiny2Api Class Doc Comment
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Destiny2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation destiny2AwaGetActionToken
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20059
     */
    public function destiny2AwaGetActionToken($correlationId)
    {
        list($response) = $this->destiny2AwaGetActionTokenWithHttpInfo($correlationId);
        return $response;
    }

    /**
     * Operation destiny2AwaGetActionTokenWithHttpInfo
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20059, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaGetActionTokenWithHttpInfo($correlationId)
    {
        $request = $this->destiny2AwaGetActionTokenRequest($correlationId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20059' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20059', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20059';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20059',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaGetActionTokenAsync
     *
     * 
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaGetActionTokenAsync($correlationId)
    {
        return $this->destiny2AwaGetActionTokenAsyncWithHttpInfo($correlationId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaGetActionTokenAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaGetActionTokenAsyncWithHttpInfo($correlationId)
    {
        $returnType = '\Bungie\Model\InlineResponse20059';
        $request = $this->destiny2AwaGetActionTokenRequest($correlationId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaGetActionToken'
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2AwaGetActionTokenRequest($correlationId)
    {
        // verify the required parameter 'correlationId' is set
        if ($correlationId === null || (is_array($correlationId) && count($correlationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $correlationId when calling destiny2AwaGetActionToken'
            );
        }

        $resourcePath = '/Destiny2/Awa/GetActionToken/{correlationId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($correlationId !== null) {
            $resourcePath = str_replace(
                '{' . 'correlationId' . '}',
                ObjectSerializer::toPathValue($correlationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2AwaInitializeRequest
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20058
     */
    public function destiny2AwaInitializeRequest()
    {
        list($response) = $this->destiny2AwaInitializeRequestWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2AwaInitializeRequestWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20058, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaInitializeRequestWithHttpInfo()
    {
        $request = $this->destiny2AwaInitializeRequestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20058' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20058', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20058';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20058',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaInitializeRequestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaInitializeRequestAsync()
    {
        return $this->destiny2AwaInitializeRequestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaInitializeRequestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaInitializeRequestAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20058';
        $request = $this->destiny2AwaInitializeRequestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaInitializeRequest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2AwaInitializeRequestRequest()
    {

        $resourcePath = '/Destiny2/Awa/Initialize/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResult
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2AwaProvideAuthorizationResult()
    {
        list($response) = $this->destiny2AwaProvideAuthorizationResultWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaProvideAuthorizationResultWithHttpInfo()
    {
        $request = $this->destiny2AwaProvideAuthorizationResultRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaProvideAuthorizationResultAsync()
    {
        return $this->destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2AwaProvideAuthorizationResultRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaProvideAuthorizationResult'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2AwaProvideAuthorizationResultRequest()
    {

        $resourcePath = '/Destiny2/Awa/AwaProvideAuthorizationResult/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2EquipItem
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2EquipItem()
    {
        list($response) = $this->destiny2EquipItemWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2EquipItemWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2EquipItemWithHttpInfo()
    {
        $request = $this->destiny2EquipItemRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2EquipItemAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemAsync()
    {
        return $this->destiny2EquipItemAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2EquipItemAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2EquipItemRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2EquipItem'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2EquipItemRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/EquipItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2EquipItems
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20044
     */
    public function destiny2EquipItems()
    {
        list($response) = $this->destiny2EquipItemsWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2EquipItemsWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2EquipItemsWithHttpInfo()
    {
        $request = $this->destiny2EquipItemsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2EquipItemsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemsAsync()
    {
        return $this->destiny2EquipItemsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2EquipItemsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemsAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20044';
        $request = $this->destiny2EquipItemsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2EquipItems'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2EquipItemsRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/EquipItems/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetActivityHistory
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20053
     */
    public function destiny2GetActivityHistory($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        list($response) = $this->destiny2GetActivityHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);
        return $response;
    }

    /**
     * Operation destiny2GetActivityHistoryWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20053, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetActivityHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        $request = $this->destiny2GetActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20053' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20053', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20053';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20053',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetActivityHistoryAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetActivityHistoryAsync($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        return $this->destiny2GetActivityHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetActivityHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetActivityHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20053';
        $request = $this->destiny2GetActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetActivityHistory'
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetActivityHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetActivityHistory'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetActivityHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetCharacter
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20038
     */
    public function destiny2GetCharacter($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->destiny2GetCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation destiny2GetCharacterWithHttpInfo
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->destiny2GetCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20038';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetCharacterAsync
     *
     * 
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCharacterAsync($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->destiny2GetCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20038';
        $request = $this->destiny2GetCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetCharacter'
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetCharacter'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetCharacter'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanAggregateStats
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20049
     */
    public function destiny2GetClanAggregateStats($groupId, $modes = null)
    {
        list($response) = $this->destiny2GetClanAggregateStatsWithHttpInfo($groupId, $modes);
        return $response;
    }

    /**
     * Operation destiny2GetClanAggregateStatsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanAggregateStatsWithHttpInfo($groupId, $modes = null)
    {
        $request = $this->destiny2GetClanAggregateStatsRequest($groupId, $modes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsync($groupId, $modes = null)
    {
        return $this->destiny2GetClanAggregateStatsAsyncWithHttpInfo($groupId, $modes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsyncWithHttpInfo($groupId, $modes = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20049';
        $request = $this->destiny2GetClanAggregateStatsRequest($groupId, $modes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanAggregateStats'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetClanAggregateStatsRequest($groupId, $modes = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling destiny2GetClanAggregateStats'
            );
        }

        $resourcePath = '/Destiny2/Stats/AggregateClanStats/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanLeaderboards
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function destiny2GetClanLeaderboards($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetClanLeaderboardsWithHttpInfo($groupId, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetClanLeaderboardsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanLeaderboardsWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsync($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->destiny2GetClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanLeaderboards'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetClanLeaderboardsRequest($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling destiny2GetClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/Clans/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanWeeklyRewardState
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20039
     */
    public function destiny2GetClanWeeklyRewardState($groupId)
    {
        list($response) = $this->destiny2GetClanWeeklyRewardStateWithHttpInfo($groupId);
        return $response;
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateWithHttpInfo
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanWeeklyRewardStateWithHttpInfo($groupId)
    {
        $request = $this->destiny2GetClanWeeklyRewardStateRequest($groupId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20039';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateAsync
     *
     * 
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanWeeklyRewardStateAsync($groupId)
    {
        return $this->destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo($groupId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo($groupId)
    {
        $returnType = '\Bungie\Model\InlineResponse20039';
        $request = $this->destiny2GetClanWeeklyRewardStateRequest($groupId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanWeeklyRewardState'
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetClanWeeklyRewardStateRequest($groupId)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling destiny2GetClanWeeklyRewardState'
            );
        }

        $resourcePath = '/Destiny2/Clan/{groupId}/WeeklyRewardState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetCollectibleNodeDetails
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20043
     */
    public function destiny2GetCollectibleNodeDetails($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->destiny2GetCollectibleNodeDetailsWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetCollectibleNodeDetailsWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->destiny2GetCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCollectibleNodeDetailsAsync($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20043';
        $request = $this->destiny2GetCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetCollectibleNodeDetails'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'collectiblePresentationNodeHash' is set
        if ($collectiblePresentationNodeHash === null || (is_array($collectiblePresentationNodeHash) && count($collectiblePresentationNodeHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collectiblePresentationNodeHash when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetCollectibleNodeDetails'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($collectiblePresentationNodeHash !== null) {
            $resourcePath = str_replace(
                '{' . 'collectiblePresentationNodeHash' . '}',
                ObjectSerializer::toPathValue($collectiblePresentationNodeHash),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStats
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20055
     */
    public function destiny2GetDestinyAggregateActivityStats($characterId, $destinyMembershipId, $membershipType)
    {
        list($response) = $this->destiny2GetDestinyAggregateActivityStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType);
        return $response;
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsWithHttpInfo
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20055, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyAggregateActivityStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $request = $this->destiny2GetDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20055' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20055', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20055';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20055',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsAsync
     *
     * 
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyAggregateActivityStatsAsync($characterId, $destinyMembershipId, $membershipType)
    {
        return $this->destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20055';
        $request = $this->destiny2GetDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyAggregateActivityStats'
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetDestinyAggregateActivityStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyEntityDefinition
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20034
     */
    public function destiny2GetDestinyEntityDefinition($entityType, $hashIdentifier)
    {
        list($response) = $this->destiny2GetDestinyEntityDefinitionWithHttpInfo($entityType, $hashIdentifier);
        return $response;
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionWithHttpInfo
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20034, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyEntityDefinitionWithHttpInfo($entityType, $hashIdentifier)
    {
        $request = $this->destiny2GetDestinyEntityDefinitionRequest($entityType, $hashIdentifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20034' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20034', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20034';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionAsync
     *
     * 
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyEntityDefinitionAsync($entityType, $hashIdentifier)
    {
        return $this->destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo($entityType, $hashIdentifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo($entityType, $hashIdentifier)
    {
        $returnType = '\Bungie\Model\InlineResponse20034';
        $request = $this->destiny2GetDestinyEntityDefinitionRequest($entityType, $hashIdentifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyEntityDefinition'
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetDestinyEntityDefinitionRequest($entityType, $hashIdentifier)
    {
        // verify the required parameter 'entityType' is set
        if ($entityType === null || (is_array($entityType) && count($entityType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityType when calling destiny2GetDestinyEntityDefinition'
            );
        }
        // verify the required parameter 'hashIdentifier' is set
        if ($hashIdentifier === null || (is_array($hashIdentifier) && count($hashIdentifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashIdentifier when calling destiny2GetDestinyEntityDefinition'
            );
        }

        $resourcePath = '/Destiny2/Manifest/{entityType}/{hashIdentifier}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entityType !== null) {
            $resourcePath = str_replace(
                '{' . 'entityType' . '}',
                ObjectSerializer::toPathValue($entityType),
                $resourcePath
            );
        }
        // path params
        if ($hashIdentifier !== null) {
            $resourcePath = str_replace(
                '{' . 'hashIdentifier' . '}',
                ObjectSerializer::toPathValue($hashIdentifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyManifest
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20033
     */
    public function destiny2GetDestinyManifest()
    {
        list($response) = $this->destiny2GetDestinyManifestWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetDestinyManifestWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20033, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyManifestWithHttpInfo()
    {
        $request = $this->destiny2GetDestinyManifestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20033' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20033', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20033';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20033',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyManifestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyManifestAsync()
    {
        return $this->destiny2GetDestinyManifestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyManifestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyManifestAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20033';
        $request = $this->destiny2GetDestinyManifestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyManifest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetDestinyManifestRequest()
    {

        $resourcePath = '/Destiny2/Manifest/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStats
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20051
     */
    public function destiny2GetHistoricalStats($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        list($response) = $this->destiny2GetHistoricalStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20051, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        $request = $this->destiny2GetHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20051' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20051', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20051';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20051',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsAsync($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        return $this->destiny2GetHistoricalStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20051';
        $request = $this->destiny2GetHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStats'
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetHistoricalStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetHistoricalStats'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetHistoricalStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dayend !== null) {
            $queryParams['dayend'] = ObjectSerializer::toQueryValue($dayend);
        }
        // query params
        if ($daystart !== null) {
            $queryParams['daystart'] = ObjectSerializer::toQueryValue($daystart);
        }
        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'csv', true);
        }
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'csv', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($periodType !== null) {
            $queryParams['periodType'] = ObjectSerializer::toQueryValue($periodType);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinition
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20047
     */
    public function destiny2GetHistoricalStatsDefinition()
    {
        list($response) = $this->destiny2GetHistoricalStatsDefinitionWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsDefinitionWithHttpInfo()
    {
        $request = $this->destiny2GetHistoricalStatsDefinitionRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsDefinitionAsync()
    {
        return $this->destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20047';
        $request = $this->destiny2GetHistoricalStatsDefinitionRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStatsDefinition'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetHistoricalStatsDefinitionRequest()
    {

        $resourcePath = '/Destiny2/Stats/Definition/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccount
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20052
     */
    public function destiny2GetHistoricalStatsForAccount($destinyMembershipId, $membershipType, $groups = null)
    {
        list($response) = $this->destiny2GetHistoricalStatsForAccountWithHttpInfo($destinyMembershipId, $membershipType, $groups);
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountWithHttpInfo
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20052, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsForAccountWithHttpInfo($destinyMembershipId, $membershipType, $groups = null)
    {
        $request = $this->destiny2GetHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20052' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20052', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20052';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20052',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsForAccountAsync($destinyMembershipId, $membershipType, $groups = null)
    {
        return $this->destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo($destinyMembershipId, $membershipType, $groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo($destinyMembershipId, $membershipType, $groups = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20052';
        $request = $this->destiny2GetHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStatsForAccount'
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyHistoricalStatsDefinitionsDestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetHistoricalStatsForAccount'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetHistoricalStatsForAccount'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'csv', true);
        }
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetItem
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20040
     */
    public function destiny2GetItem($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        list($response) = $this->destiny2GetItemWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation destiny2GetItemWithHttpInfo
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetItemWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        $request = $this->destiny2GetItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20040' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20040', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20040';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetItemAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetItemAsync($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        return $this->destiny2GetItemAsyncWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetItemAsyncWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20040';
        $request = $this->destiny2GetItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetItem'
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetItem'
            );
        }
        // verify the required parameter 'itemInstanceId' is set
        if ($itemInstanceId === null || (is_array($itemInstanceId) && count($itemInstanceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemInstanceId when calling destiny2GetItem'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetItem'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($itemInstanceId !== null) {
            $resourcePath = str_replace(
                '{' . 'itemInstanceId' . '}',
                ObjectSerializer::toPathValue($itemInstanceId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboards
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function destiny2GetLeaderboards($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsWithHttpInfo
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsync($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->destiny2GetLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboards'
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetLeaderboards'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacter
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function destiny2GetLeaderboardsForCharacter($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterWithHttpInfo
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsync($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboardsForCharacter'
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLinkedProfiles
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20036
     */
    public function destiny2GetLinkedProfiles($membershipId, $membershipType)
    {
        list($response) = $this->destiny2GetLinkedProfilesWithHttpInfo($membershipId, $membershipType);
        return $response;
    }

    /**
     * Operation destiny2GetLinkedProfilesWithHttpInfo
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLinkedProfilesWithHttpInfo($membershipId, $membershipType)
    {
        $request = $this->destiny2GetLinkedProfilesRequest($membershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLinkedProfilesAsync
     *
     * 
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLinkedProfilesAsync($membershipId, $membershipType)
    {
        return $this->destiny2GetLinkedProfilesAsyncWithHttpInfo($membershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLinkedProfilesAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLinkedProfilesAsyncWithHttpInfo($membershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20036';
        $request = $this->destiny2GetLinkedProfilesRequest($membershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLinkedProfiles'
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetLinkedProfilesRequest($membershipId, $membershipType)
    {
        // verify the required parameter 'membershipId' is set
        if ($membershipId === null || (is_array($membershipId) && count($membershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipId when calling destiny2GetLinkedProfiles'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetLinkedProfiles'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($membershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipId' . '}',
                ObjectSerializer::toPathValue($membershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPostGameCarnageReport
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20046
     */
    public function destiny2GetPostGameCarnageReport($activityId)
    {
        list($response) = $this->destiny2GetPostGameCarnageReportWithHttpInfo($activityId);
        return $response;
    }

    /**
     * Operation destiny2GetPostGameCarnageReportWithHttpInfo
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPostGameCarnageReportWithHttpInfo($activityId)
    {
        $request = $this->destiny2GetPostGameCarnageReportRequest($activityId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPostGameCarnageReportAsync
     *
     * 
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPostGameCarnageReportAsync($activityId)
    {
        return $this->destiny2GetPostGameCarnageReportAsyncWithHttpInfo($activityId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPostGameCarnageReportAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPostGameCarnageReportAsyncWithHttpInfo($activityId)
    {
        $returnType = '\Bungie\Model\InlineResponse20046';
        $request = $this->destiny2GetPostGameCarnageReportRequest($activityId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPostGameCarnageReport'
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetPostGameCarnageReportRequest($activityId)
    {
        // verify the required parameter 'activityId' is set
        if ($activityId === null || (is_array($activityId) && count($activityId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activityId when calling destiny2GetPostGameCarnageReport'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($activityId !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetProfile
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20037
     */
    public function destiny2GetProfile($destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->destiny2GetProfileWithHttpInfo($destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation destiny2GetProfileWithHttpInfo
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetProfileWithHttpInfo($destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->destiny2GetProfileRequest($destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20037';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetProfileAsync
     *
     * 
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetProfileAsync($destinyMembershipId, $membershipType, $components = null)
    {
        return $this->destiny2GetProfileAsyncWithHttpInfo($destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetProfileAsyncWithHttpInfo($destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20037';
        $request = $this->destiny2GetProfileRequest($destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetProfile'
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetProfileRequest($destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetProfile'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetProfile'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicMilestoneContent
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20056
     */
    public function destiny2GetPublicMilestoneContent($milestoneHash)
    {
        list($response) = $this->destiny2GetPublicMilestoneContentWithHttpInfo($milestoneHash);
        return $response;
    }

    /**
     * Operation destiny2GetPublicMilestoneContentWithHttpInfo
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20056, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicMilestoneContentWithHttpInfo($milestoneHash)
    {
        $request = $this->destiny2GetPublicMilestoneContentRequest($milestoneHash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20056' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20056', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20056';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20056',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicMilestoneContentAsync
     *
     * 
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestoneContentAsync($milestoneHash)
    {
        return $this->destiny2GetPublicMilestoneContentAsyncWithHttpInfo($milestoneHash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicMilestoneContentAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestoneContentAsyncWithHttpInfo($milestoneHash)
    {
        $returnType = '\Bungie\Model\InlineResponse20056';
        $request = $this->destiny2GetPublicMilestoneContentRequest($milestoneHash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicMilestoneContent'
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetPublicMilestoneContentRequest($milestoneHash)
    {
        // verify the required parameter 'milestoneHash' is set
        if ($milestoneHash === null || (is_array($milestoneHash) && count($milestoneHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestoneHash when calling destiny2GetPublicMilestoneContent'
            );
        }

        $resourcePath = '/Destiny2/Milestones/{milestoneHash}/Content/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestoneHash !== null) {
            $resourcePath = str_replace(
                '{' . 'milestoneHash' . '}',
                ObjectSerializer::toPathValue($milestoneHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicMilestones
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20057
     */
    public function destiny2GetPublicMilestones()
    {
        list($response) = $this->destiny2GetPublicMilestonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetPublicMilestonesWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20057, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicMilestonesWithHttpInfo()
    {
        $request = $this->destiny2GetPublicMilestonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20057' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20057', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20057';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20057',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicMilestonesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestonesAsync()
    {
        return $this->destiny2GetPublicMilestonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicMilestonesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestonesAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20057';
        $request = $this->destiny2GetPublicMilestonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicMilestones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetPublicMilestonesRequest()
    {

        $resourcePath = '/Destiny2/Milestones/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetUniqueWeaponHistory
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20054
     */
    public function destiny2GetUniqueWeaponHistory($characterId, $destinyMembershipId, $membershipType)
    {
        list($response) = $this->destiny2GetUniqueWeaponHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType);
        return $response;
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20054, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetUniqueWeaponHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $request = $this->destiny2GetUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20054' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20054', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20054';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20054',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetUniqueWeaponHistoryAsync($characterId, $destinyMembershipId, $membershipType)
    {
        return $this->destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20054';
        $request = $this->destiny2GetUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetUniqueWeaponHistory'
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetUniqueWeaponHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetVendor
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20042
     */
    public function destiny2GetVendor($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        list($response) = $this->destiny2GetVendorWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);
        return $response;
    }

    /**
     * Operation destiny2GetVendorWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20042, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetVendorWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        $request = $this->destiny2GetVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20042' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20042', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20042';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetVendorAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorAsync($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        return $this->destiny2GetVendorAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetVendorAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20042';
        $request = $this->destiny2GetVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetVendor'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling destiny2GetVendor'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetVendors
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20041
     */
    public function destiny2GetVendors($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->destiny2GetVendorsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation destiny2GetVendorsWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetVendorsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->destiny2GetVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20041';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetVendorsAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorsAsync($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->destiny2GetVendorsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20041';
        $request = $this->destiny2GetVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetVendors'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\DestinyDestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2GetVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling destiny2GetVendors'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling destiny2GetVendors'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2GetVendors'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'csv', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2InsertSocketPlug
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20045
     */
    public function destiny2InsertSocketPlug()
    {
        list($response) = $this->destiny2InsertSocketPlugWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2InsertSocketPlugWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20045, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2InsertSocketPlugWithHttpInfo()
    {
        $request = $this->destiny2InsertSocketPlugRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20045' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20045', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20045';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20045',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2InsertSocketPlugAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsync()
    {
        return $this->destiny2InsertSocketPlugAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2InsertSocketPlugAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20045';
        $request = $this->destiny2InsertSocketPlugRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2InsertSocketPlug'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2InsertSocketPlugRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/InsertSocketPlug/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2PullFromPostmaster
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2PullFromPostmaster()
    {
        list($response) = $this->destiny2PullFromPostmasterWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2PullFromPostmasterWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2PullFromPostmasterWithHttpInfo()
    {
        $request = $this->destiny2PullFromPostmasterRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2PullFromPostmasterAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2PullFromPostmasterAsync()
    {
        return $this->destiny2PullFromPostmasterAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2PullFromPostmasterAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2PullFromPostmasterAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2PullFromPostmasterRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2PullFromPostmaster'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2PullFromPostmasterRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/PullFromPostmaster/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayer
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayer($activityId)
    {
        list($response) = $this->destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo($activityId);
        return $response;
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo($activityId)
    {
        $request = $this->destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activityId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerAsync
     *
     * 
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerAsync($activityId)
    {
        return $this->destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activityId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activityId)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activityId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2ReportOffensivePostGameCarnageReportPlayer'
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activityId)
    {
        // verify the required parameter 'activityId' is set
        if ($activityId === null || (is_array($activityId) && count($activityId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activityId when calling destiny2ReportOffensivePostGameCarnageReportPlayer'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($activityId !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SearchDestinyEntities
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20050
     */
    public function destiny2SearchDestinyEntities($searchTerm, $type, $page = null)
    {
        list($response) = $this->destiny2SearchDestinyEntitiesWithHttpInfo($searchTerm, $type, $page);
        return $response;
    }

    /**
     * Operation destiny2SearchDestinyEntitiesWithHttpInfo
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SearchDestinyEntitiesWithHttpInfo($searchTerm, $type, $page = null)
    {
        $request = $this->destiny2SearchDestinyEntitiesRequest($searchTerm, $type, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SearchDestinyEntitiesAsync
     *
     * 
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyEntitiesAsync($searchTerm, $type, $page = null)
    {
        return $this->destiny2SearchDestinyEntitiesAsyncWithHttpInfo($searchTerm, $type, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SearchDestinyEntitiesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyEntitiesAsyncWithHttpInfo($searchTerm, $type, $page = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20050';
        $request = $this->destiny2SearchDestinyEntitiesRequest($searchTerm, $type, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SearchDestinyEntities'
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2SearchDestinyEntitiesRequest($searchTerm, $type, $page = null)
    {
        // verify the required parameter 'searchTerm' is set
        if ($searchTerm === null || (is_array($searchTerm) && count($searchTerm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchTerm when calling destiny2SearchDestinyEntities'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling destiny2SearchDestinyEntities'
            );
        }

        $resourcePath = '/Destiny2/Armory/Search/{type}/{searchTerm}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }

        // path params
        if ($searchTerm !== null) {
            $resourcePath = str_replace(
                '{' . 'searchTerm' . '}',
                ObjectSerializer::toPathValue($searchTerm),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SearchDestinyPlayer
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20035
     */
    public function destiny2SearchDestinyPlayer($displayName, $membershipType)
    {
        list($response) = $this->destiny2SearchDestinyPlayerWithHttpInfo($displayName, $membershipType);
        return $response;
    }

    /**
     * Operation destiny2SearchDestinyPlayerWithHttpInfo
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SearchDestinyPlayerWithHttpInfo($displayName, $membershipType)
    {
        $request = $this->destiny2SearchDestinyPlayerRequest($displayName, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20035' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20035', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20035';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SearchDestinyPlayerAsync
     *
     * 
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyPlayerAsync($displayName, $membershipType)
    {
        return $this->destiny2SearchDestinyPlayerAsyncWithHttpInfo($displayName, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SearchDestinyPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyPlayerAsyncWithHttpInfo($displayName, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20035';
        $request = $this->destiny2SearchDestinyPlayerRequest($displayName, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SearchDestinyPlayer'
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2SearchDestinyPlayerRequest($displayName, $membershipType)
    {
        // verify the required parameter 'displayName' is set
        if ($displayName === null || (is_array($displayName) && count($displayName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $displayName when calling destiny2SearchDestinyPlayer'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling destiny2SearchDestinyPlayer'
            );
        }

        $resourcePath = '/Destiny2/SearchDestinyPlayer/{membershipType}/{displayName}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($displayName !== null) {
            $resourcePath = str_replace(
                '{' . 'displayName' . '}',
                ObjectSerializer::toPathValue($displayName),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SetItemLockState
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2SetItemLockState()
    {
        list($response) = $this->destiny2SetItemLockStateWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2SetItemLockStateWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SetItemLockStateWithHttpInfo()
    {
        $request = $this->destiny2SetItemLockStateRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SetItemLockStateAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetItemLockStateAsync()
    {
        return $this->destiny2SetItemLockStateAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SetItemLockStateAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetItemLockStateAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2SetItemLockStateRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SetItemLockState'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2SetItemLockStateRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/SetLockState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2TransferItem
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function destiny2TransferItem()
    {
        list($response) = $this->destiny2TransferItemWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2TransferItemWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2TransferItemWithHttpInfo()
    {
        $request = $this->destiny2TransferItemRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2TransferItemAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2TransferItemAsync()
    {
        return $this->destiny2TransferItemAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2TransferItemAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2TransferItemAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->destiny2TransferItemRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2TransferItem'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destiny2TransferItemRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/TransferItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
