<?php
/**
 * Destiny2Api
 * PHP version 5
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.3
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bungie\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bungie\ApiException;
use Bungie\Configuration;
use Bungie\HeaderSelector;
use Bungie\ObjectSerializer;

/**
 * Destiny2Api Class Doc Comment
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Destiny2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation awaGetActionToken
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20059
     */
    public function awaGetActionToken($correlationId)
    {
        list($response) = $this->awaGetActionTokenWithHttpInfo($correlationId);
        return $response;
    }

    /**
     * Operation awaGetActionTokenWithHttpInfo
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20059, HTTP status code, HTTP response headers (array of strings)
     */
    public function awaGetActionTokenWithHttpInfo($correlationId)
    {
        $request = $this->awaGetActionTokenRequest($correlationId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20059' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20059', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20059';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20059',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation awaGetActionTokenAsync
     *
     * 
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaGetActionTokenAsync($correlationId)
    {
        return $this->awaGetActionTokenAsyncWithHttpInfo($correlationId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation awaGetActionTokenAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaGetActionTokenAsyncWithHttpInfo($correlationId)
    {
        $returnType = '\Bungie\Model\InlineResponse20059';
        $request = $this->awaGetActionTokenRequest($correlationId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'awaGetActionToken'
     *
     * @param  string $correlationId The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function awaGetActionTokenRequest($correlationId)
    {
        // verify the required parameter 'correlationId' is set
        if ($correlationId === null || (is_array($correlationId) && count($correlationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $correlationId when calling awaGetActionToken'
            );
        }

        $resourcePath = '/Destiny2/Awa/GetActionToken/{correlationId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($correlationId !== null) {
            $resourcePath = str_replace(
                '{' . 'correlationId' . '}',
                ObjectSerializer::toPathValue($correlationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation awaInitializeRequest
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaPermissionRequested $awaPermissionRequested awaPermissionRequested (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20058
     */
    public function awaInitializeRequest($awaPermissionRequested)
    {
        list($response) = $this->awaInitializeRequestWithHttpInfo($awaPermissionRequested);
        return $response;
    }

    /**
     * Operation awaInitializeRequestWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaPermissionRequested $awaPermissionRequested (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20058, HTTP status code, HTTP response headers (array of strings)
     */
    public function awaInitializeRequestWithHttpInfo($awaPermissionRequested)
    {
        $request = $this->awaInitializeRequestRequest($awaPermissionRequested);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20058' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20058', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20058';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20058',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation awaInitializeRequestAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaPermissionRequested $awaPermissionRequested (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaInitializeRequestAsync($awaPermissionRequested)
    {
        return $this->awaInitializeRequestAsyncWithHttpInfo($awaPermissionRequested)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation awaInitializeRequestAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaPermissionRequested $awaPermissionRequested (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaInitializeRequestAsyncWithHttpInfo($awaPermissionRequested)
    {
        $returnType = '\Bungie\Model\InlineResponse20058';
        $request = $this->awaInitializeRequestRequest($awaPermissionRequested);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'awaInitializeRequest'
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaPermissionRequested $awaPermissionRequested (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function awaInitializeRequestRequest($awaPermissionRequested)
    {
        // verify the required parameter 'awaPermissionRequested' is set
        if ($awaPermissionRequested === null || (is_array($awaPermissionRequested) && count($awaPermissionRequested) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $awaPermissionRequested when calling awaInitializeRequest'
            );
        }

        $resourcePath = '/Destiny2/Awa/Initialize/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($awaPermissionRequested)) {
            $_tempBody = $awaPermissionRequested;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation awaProvideAuthorizationResult
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaUserResponse $awaUserResponse awaUserResponse (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function awaProvideAuthorizationResult($awaUserResponse)
    {
        list($response) = $this->awaProvideAuthorizationResultWithHttpInfo($awaUserResponse);
        return $response;
    }

    /**
     * Operation awaProvideAuthorizationResultWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaUserResponse $awaUserResponse (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function awaProvideAuthorizationResultWithHttpInfo($awaUserResponse)
    {
        $request = $this->awaProvideAuthorizationResultRequest($awaUserResponse);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation awaProvideAuthorizationResultAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaUserResponse $awaUserResponse (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaProvideAuthorizationResultAsync($awaUserResponse)
    {
        return $this->awaProvideAuthorizationResultAsyncWithHttpInfo($awaUserResponse)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation awaProvideAuthorizationResultAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaUserResponse $awaUserResponse (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function awaProvideAuthorizationResultAsyncWithHttpInfo($awaUserResponse)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->awaProvideAuthorizationResultRequest($awaUserResponse);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'awaProvideAuthorizationResult'
     *
     * @param  \Bungie\Model\Destiny\Advanced\AwaUserResponse $awaUserResponse (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function awaProvideAuthorizationResultRequest($awaUserResponse)
    {
        // verify the required parameter 'awaUserResponse' is set
        if ($awaUserResponse === null || (is_array($awaUserResponse) && count($awaUserResponse) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $awaUserResponse when calling awaProvideAuthorizationResult'
            );
        }

        $resourcePath = '/Destiny2/Awa/AwaProvideAuthorizationResult/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($awaUserResponse)) {
            $_tempBody = $awaUserResponse;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation equipItem
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemActionRequest $destinyItemActionRequest destinyItemActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function equipItem($destinyItemActionRequest)
    {
        list($response) = $this->equipItemWithHttpInfo($destinyItemActionRequest);
        return $response;
    }

    /**
     * Operation equipItemWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemActionRequest $destinyItemActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipItemWithHttpInfo($destinyItemActionRequest)
    {
        $request = $this->equipItemRequest($destinyItemActionRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipItemAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemActionRequest $destinyItemActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemAsync($destinyItemActionRequest)
    {
        return $this->equipItemAsyncWithHttpInfo($destinyItemActionRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemActionRequest $destinyItemActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemAsyncWithHttpInfo($destinyItemActionRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->equipItemRequest($destinyItemActionRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipItem'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemActionRequest $destinyItemActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function equipItemRequest($destinyItemActionRequest)
    {
        // verify the required parameter 'destinyItemActionRequest' is set
        if ($destinyItemActionRequest === null || (is_array($destinyItemActionRequest) && count($destinyItemActionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyItemActionRequest when calling equipItem'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/EquipItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyItemActionRequest)) {
            $_tempBody = $destinyItemActionRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation equipItems
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemSetActionRequest $destinyItemSetActionRequest destinyItemSetActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20044
     */
    public function equipItems($destinyItemSetActionRequest)
    {
        list($response) = $this->equipItemsWithHttpInfo($destinyItemSetActionRequest);
        return $response;
    }

    /**
     * Operation equipItemsWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemSetActionRequest $destinyItemSetActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipItemsWithHttpInfo($destinyItemSetActionRequest)
    {
        $request = $this->equipItemsRequest($destinyItemSetActionRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipItemsAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemSetActionRequest $destinyItemSetActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemsAsync($destinyItemSetActionRequest)
    {
        return $this->equipItemsAsyncWithHttpInfo($destinyItemSetActionRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipItemsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemSetActionRequest $destinyItemSetActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemsAsyncWithHttpInfo($destinyItemSetActionRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20044';
        $request = $this->equipItemsRequest($destinyItemSetActionRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipItems'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemSetActionRequest $destinyItemSetActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function equipItemsRequest($destinyItemSetActionRequest)
    {
        // verify the required parameter 'destinyItemSetActionRequest' is set
        if ($destinyItemSetActionRequest === null || (is_array($destinyItemSetActionRequest) && count($destinyItemSetActionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyItemSetActionRequest when calling equipItems'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/EquipItems/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyItemSetActionRequest)) {
            $_tempBody = $destinyItemSetActionRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityHistory
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20053
     */
    public function getActivityHistory($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        list($response) = $this->getActivityHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);
        return $response;
    }

    /**
     * Operation getActivityHistoryWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20053, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        $request = $this->getActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20053' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20053', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20053';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20053',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityHistoryAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityHistoryAsync($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        return $this->getActivityHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20053';
        $request = $this->getActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count, $mode, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityHistory'
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityHistoryRequest($characterId, $destinyMembershipId, $membershipType, $count = null, $mode = null, $page = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getActivityHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getActivityHistory'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getActivityHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacter
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20038
     */
    public function getCharacter($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->getCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation getCharacterWithHttpInfo
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->getCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20038';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterAsync
     *
     * 
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterAsync($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->getCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20038';
        $request = $this->getCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacter'
     *
     * @param  int $characterId ID of the character. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterRequest($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacter'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacter'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', true);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClanAggregateStats
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20049
     */
    public function getClanAggregateStats($groupId, $modes = null)
    {
        list($response) = $this->getClanAggregateStatsWithHttpInfo($groupId, $modes);
        return $response;
    }

    /**
     * Operation getClanAggregateStatsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanAggregateStatsWithHttpInfo($groupId, $modes = null)
    {
        $request = $this->getClanAggregateStatsRequest($groupId, $modes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanAggregateStatsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanAggregateStatsAsync($groupId, $modes = null)
    {
        return $this->getClanAggregateStatsAsyncWithHttpInfo($groupId, $modes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanAggregateStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanAggregateStatsAsyncWithHttpInfo($groupId, $modes = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20049';
        $request = $this->getClanAggregateStatsRequest($groupId, $modes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanAggregateStats'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanAggregateStatsRequest($groupId, $modes = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getClanAggregateStats'
            );
        }

        $resourcePath = '/Destiny2/Stats/AggregateClanStats/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClanLeaderboards
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function getClanLeaderboards($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getClanLeaderboardsWithHttpInfo($groupId, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getClanLeaderboardsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanLeaderboardsWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsync($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->getClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanLeaderboards'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanLeaderboardsRequest($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/Clans/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClanWeeklyRewardState
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20039
     */
    public function getClanWeeklyRewardState($groupId)
    {
        list($response) = $this->getClanWeeklyRewardStateWithHttpInfo($groupId);
        return $response;
    }

    /**
     * Operation getClanWeeklyRewardStateWithHttpInfo
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanWeeklyRewardStateWithHttpInfo($groupId)
    {
        $request = $this->getClanWeeklyRewardStateRequest($groupId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20039';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanWeeklyRewardStateAsync
     *
     * 
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanWeeklyRewardStateAsync($groupId)
    {
        return $this->getClanWeeklyRewardStateAsyncWithHttpInfo($groupId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanWeeklyRewardStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanWeeklyRewardStateAsyncWithHttpInfo($groupId)
    {
        $returnType = '\Bungie\Model\InlineResponse20039';
        $request = $this->getClanWeeklyRewardStateRequest($groupId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanWeeklyRewardState'
     *
     * @param  int $groupId A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanWeeklyRewardStateRequest($groupId)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getClanWeeklyRewardState'
            );
        }

        $resourcePath = '/Destiny2/Clan/{groupId}/WeeklyRewardState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollectibleNodeDetails
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20043
     */
    public function getCollectibleNodeDetails($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->getCollectibleNodeDetailsWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation getCollectibleNodeDetailsWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectibleNodeDetailsWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->getCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCollectibleNodeDetailsAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectibleNodeDetailsAsync($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->getCollectibleNodeDetailsAsyncWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectibleNodeDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectibleNodeDetailsAsyncWithHttpInfo($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20043';
        $request = $this->getCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollectibleNodeDetails'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectiblePresentationNodeHash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectibleNodeDetailsRequest($characterId, $collectiblePresentationNodeHash, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'collectiblePresentationNodeHash' is set
        if ($collectiblePresentationNodeHash === null || (is_array($collectiblePresentationNodeHash) && count($collectiblePresentationNodeHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collectiblePresentationNodeHash when calling getCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCollectibleNodeDetails'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($collectiblePresentationNodeHash !== null) {
            $resourcePath = str_replace(
                '{' . 'collectiblePresentationNodeHash' . '}',
                ObjectSerializer::toPathValue($collectiblePresentationNodeHash),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyAggregateActivityStats
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20055
     */
    public function getDestinyAggregateActivityStats($characterId, $destinyMembershipId, $membershipType)
    {
        list($response) = $this->getDestinyAggregateActivityStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType);
        return $response;
    }

    /**
     * Operation getDestinyAggregateActivityStatsWithHttpInfo
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20055, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyAggregateActivityStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $request = $this->getDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20055' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20055', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20055';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20055',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyAggregateActivityStatsAsync
     *
     * 
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyAggregateActivityStatsAsync($characterId, $destinyMembershipId, $membershipType)
    {
        return $this->getDestinyAggregateActivityStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyAggregateActivityStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyAggregateActivityStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20055';
        $request = $this->getDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyAggregateActivityStats'
     *
     * @param  int $characterId The specific character whose activities should be returned. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyAggregateActivityStatsRequest($characterId, $destinyMembershipId, $membershipType)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getDestinyAggregateActivityStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyEntityDefinition
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20034
     */
    public function getDestinyEntityDefinition($entityType, $hashIdentifier)
    {
        list($response) = $this->getDestinyEntityDefinitionWithHttpInfo($entityType, $hashIdentifier);
        return $response;
    }

    /**
     * Operation getDestinyEntityDefinitionWithHttpInfo
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20034, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyEntityDefinitionWithHttpInfo($entityType, $hashIdentifier)
    {
        $request = $this->getDestinyEntityDefinitionRequest($entityType, $hashIdentifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20034' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20034', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20034';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyEntityDefinitionAsync
     *
     * 
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyEntityDefinitionAsync($entityType, $hashIdentifier)
    {
        return $this->getDestinyEntityDefinitionAsyncWithHttpInfo($entityType, $hashIdentifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyEntityDefinitionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyEntityDefinitionAsyncWithHttpInfo($entityType, $hashIdentifier)
    {
        $returnType = '\Bungie\Model\InlineResponse20034';
        $request = $this->getDestinyEntityDefinitionRequest($entityType, $hashIdentifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyEntityDefinition'
     *
     * @param  string $entityType The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hashIdentifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyEntityDefinitionRequest($entityType, $hashIdentifier)
    {
        // verify the required parameter 'entityType' is set
        if ($entityType === null || (is_array($entityType) && count($entityType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityType when calling getDestinyEntityDefinition'
            );
        }
        // verify the required parameter 'hashIdentifier' is set
        if ($hashIdentifier === null || (is_array($hashIdentifier) && count($hashIdentifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashIdentifier when calling getDestinyEntityDefinition'
            );
        }

        $resourcePath = '/Destiny2/Manifest/{entityType}/{hashIdentifier}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entityType !== null) {
            $resourcePath = str_replace(
                '{' . 'entityType' . '}',
                ObjectSerializer::toPathValue($entityType),
                $resourcePath
            );
        }
        // path params
        if ($hashIdentifier !== null) {
            $resourcePath = str_replace(
                '{' . 'hashIdentifier' . '}',
                ObjectSerializer::toPathValue($hashIdentifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyManifest
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20033
     */
    public function getDestinyManifest()
    {
        list($response) = $this->getDestinyManifestWithHttpInfo();
        return $response;
    }

    /**
     * Operation getDestinyManifestWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20033, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyManifestWithHttpInfo()
    {
        $request = $this->getDestinyManifestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20033' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20033', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20033';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20033',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyManifestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyManifestAsync()
    {
        return $this->getDestinyManifestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyManifestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyManifestAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20033';
        $request = $this->getDestinyManifestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyManifest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyManifestRequest()
    {

        $resourcePath = '/Destiny2/Manifest/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStats
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\PeriodType $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20051
     */
    public function getHistoricalStats($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        list($response) = $this->getHistoricalStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);
        return $response;
    }

    /**
     * Operation getHistoricalStatsWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\PeriodType $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20051, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        $request = $this->getHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20051' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20051', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20051';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20051',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\PeriodType $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsAsync($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        return $this->getHistoricalStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\PeriodType $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20051';
        $request = $this->getHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend, $daystart, $groups, $modes, $periodType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStats'
     *
     * @param  int $characterId The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyActivityModeType[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\PeriodType $periodType Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsRequest($characterId, $destinyMembershipId, $membershipType, $dayend = null, $daystart = null, $groups = null, $modes = null, $periodType = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getHistoricalStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getHistoricalStats'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getHistoricalStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dayend !== null) {
            $queryParams['dayend'] = ObjectSerializer::toQueryValue($dayend);
        }
        // query params
        if ($daystart !== null) {
            $queryParams['daystart'] = ObjectSerializer::toQueryValue($daystart);
        }
        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'multi', false);
        }
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'multi', false);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($periodType !== null) {
            $queryParams['periodType'] = ObjectSerializer::toQueryValue($periodType);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStatsDefinition
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20047
     */
    public function getHistoricalStatsDefinition()
    {
        list($response) = $this->getHistoricalStatsDefinitionWithHttpInfo();
        return $response;
    }

    /**
     * Operation getHistoricalStatsDefinitionWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsDefinitionWithHttpInfo()
    {
        $request = $this->getHistoricalStatsDefinitionRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsDefinitionAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsDefinitionAsync()
    {
        return $this->getHistoricalStatsDefinitionAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsDefinitionAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsDefinitionAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20047';
        $request = $this->getHistoricalStatsDefinitionRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStatsDefinition'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsDefinitionRequest()
    {

        $resourcePath = '/Destiny2/Stats/Definition/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStatsForAccount
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20052
     */
    public function getHistoricalStatsForAccount($destinyMembershipId, $membershipType, $groups = null)
    {
        list($response) = $this->getHistoricalStatsForAccountWithHttpInfo($destinyMembershipId, $membershipType, $groups);
        return $response;
    }

    /**
     * Operation getHistoricalStatsForAccountWithHttpInfo
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20052, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsForAccountWithHttpInfo($destinyMembershipId, $membershipType, $groups = null)
    {
        $request = $this->getHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20052' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20052', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20052';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20052',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsForAccountAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsForAccountAsync($destinyMembershipId, $membershipType, $groups = null)
    {
        return $this->getHistoricalStatsForAccountAsyncWithHttpInfo($destinyMembershipId, $membershipType, $groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsForAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsForAccountAsyncWithHttpInfo($destinyMembershipId, $membershipType, $groups = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20052';
        $request = $this->getHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStatsForAccount'
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\HistoricalStats\Definitions\DestinyStatsGroupType[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsForAccountRequest($destinyMembershipId, $membershipType, $groups = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getHistoricalStatsForAccount'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getHistoricalStatsForAccount'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'multi', false);
        }
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItem
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20040
     */
    public function getItem($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        list($response) = $this->getItemWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation getItemWithHttpInfo
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        $request = $this->getItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20040' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20040', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20040';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemAsync($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        return $this->getItemAsyncWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemAsyncWithHttpInfo($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20040';
        $request = $this->getItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItem'
     *
     * @param  int $destinyMembershipId The membership ID of the destiny profile. (required)
     * @param  int $itemInstanceId The Instance ID of the destiny item. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getItemRequest($destinyMembershipId, $itemInstanceId, $membershipType, $components = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getItem'
            );
        }
        // verify the required parameter 'itemInstanceId' is set
        if ($itemInstanceId === null || (is_array($itemInstanceId) && count($itemInstanceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemInstanceId when calling getItem'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getItem'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($itemInstanceId !== null) {
            $resourcePath = str_replace(
                '{' . 'itemInstanceId' . '}',
                ObjectSerializer::toPathValue($itemInstanceId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboards
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function getLeaderboards($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getLeaderboardsWithHttpInfo
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsync($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboards'
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getLeaderboards'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboardsForCharacter
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20048
     */
    public function getLeaderboardsForCharacter($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getLeaderboardsForCharacterWithHttpInfo
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsync($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20048';
        $request = $this->getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboardsForCharacter'
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLinkedProfiles
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20036
     */
    public function getLinkedProfiles($membershipId, $membershipType)
    {
        list($response) = $this->getLinkedProfilesWithHttpInfo($membershipId, $membershipType);
        return $response;
    }

    /**
     * Operation getLinkedProfilesWithHttpInfo
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedProfilesWithHttpInfo($membershipId, $membershipType)
    {
        $request = $this->getLinkedProfilesRequest($membershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLinkedProfilesAsync
     *
     * 
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedProfilesAsync($membershipId, $membershipType)
    {
        return $this->getLinkedProfilesAsyncWithHttpInfo($membershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkedProfilesAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedProfilesAsyncWithHttpInfo($membershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20036';
        $request = $this->getLinkedProfilesRequest($membershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkedProfiles'
     *
     * @param  int $membershipId The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType The type for the membership whose linked Destiny accounts you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLinkedProfilesRequest($membershipId, $membershipType)
    {
        // verify the required parameter 'membershipId' is set
        if ($membershipId === null || (is_array($membershipId) && count($membershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipId when calling getLinkedProfiles'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLinkedProfiles'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($membershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipId' . '}',
                ObjectSerializer::toPathValue($membershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPostGameCarnageReport
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20046
     */
    public function getPostGameCarnageReport($activityId)
    {
        list($response) = $this->getPostGameCarnageReportWithHttpInfo($activityId);
        return $response;
    }

    /**
     * Operation getPostGameCarnageReportWithHttpInfo
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPostGameCarnageReportWithHttpInfo($activityId)
    {
        $request = $this->getPostGameCarnageReportRequest($activityId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPostGameCarnageReportAsync
     *
     * 
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostGameCarnageReportAsync($activityId)
    {
        return $this->getPostGameCarnageReportAsyncWithHttpInfo($activityId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPostGameCarnageReportAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostGameCarnageReportAsyncWithHttpInfo($activityId)
    {
        $returnType = '\Bungie\Model\InlineResponse20046';
        $request = $this->getPostGameCarnageReportRequest($activityId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPostGameCarnageReport'
     *
     * @param  int $activityId The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPostGameCarnageReportRequest($activityId)
    {
        // verify the required parameter 'activityId' is set
        if ($activityId === null || (is_array($activityId) && count($activityId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activityId when calling getPostGameCarnageReport'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($activityId !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfile
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20037
     */
    public function getProfile($destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->getProfileWithHttpInfo($destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation getProfileWithHttpInfo
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfileWithHttpInfo($destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->getProfileRequest($destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20037';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfileAsync
     *
     * 
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsync($destinyMembershipId, $membershipType, $components = null)
    {
        return $this->getProfileAsyncWithHttpInfo($destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsyncWithHttpInfo($destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20037';
        $request = $this->getProfileRequest($destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfile'
     *
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProfileRequest($destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getProfile'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getProfile'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicMilestoneContent
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20056
     */
    public function getPublicMilestoneContent($milestoneHash)
    {
        list($response) = $this->getPublicMilestoneContentWithHttpInfo($milestoneHash);
        return $response;
    }

    /**
     * Operation getPublicMilestoneContentWithHttpInfo
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20056, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicMilestoneContentWithHttpInfo($milestoneHash)
    {
        $request = $this->getPublicMilestoneContentRequest($milestoneHash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20056' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20056', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20056';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20056',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicMilestoneContentAsync
     *
     * 
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicMilestoneContentAsync($milestoneHash)
    {
        return $this->getPublicMilestoneContentAsyncWithHttpInfo($milestoneHash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicMilestoneContentAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicMilestoneContentAsyncWithHttpInfo($milestoneHash)
    {
        $returnType = '\Bungie\Model\InlineResponse20056';
        $request = $this->getPublicMilestoneContentRequest($milestoneHash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicMilestoneContent'
     *
     * @param  int $milestoneHash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicMilestoneContentRequest($milestoneHash)
    {
        // verify the required parameter 'milestoneHash' is set
        if ($milestoneHash === null || (is_array($milestoneHash) && count($milestoneHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestoneHash when calling getPublicMilestoneContent'
            );
        }

        $resourcePath = '/Destiny2/Milestones/{milestoneHash}/Content/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestoneHash !== null) {
            $resourcePath = str_replace(
                '{' . 'milestoneHash' . '}',
                ObjectSerializer::toPathValue($milestoneHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicMilestones
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20057
     */
    public function getPublicMilestones()
    {
        list($response) = $this->getPublicMilestonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPublicMilestonesWithHttpInfo
     *
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20057, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicMilestonesWithHttpInfo()
    {
        $request = $this->getPublicMilestonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20057' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20057', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20057';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20057',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicMilestonesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicMilestonesAsync()
    {
        return $this->getPublicMilestonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicMilestonesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicMilestonesAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\Model\InlineResponse20057';
        $request = $this->getPublicMilestonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicMilestones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicMilestonesRequest()
    {

        $resourcePath = '/Destiny2/Milestones/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUniqueWeaponHistory
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20054
     */
    public function getUniqueWeaponHistory($characterId, $destinyMembershipId, $membershipType)
    {
        list($response) = $this->getUniqueWeaponHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType);
        return $response;
    }

    /**
     * Operation getUniqueWeaponHistoryWithHttpInfo
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20054, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUniqueWeaponHistoryWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $request = $this->getUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20054' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20054', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20054';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20054',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUniqueWeaponHistoryAsync
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUniqueWeaponHistoryAsync($characterId, $destinyMembershipId, $membershipType)
    {
        return $this->getUniqueWeaponHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUniqueWeaponHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUniqueWeaponHistoryAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20054';
        $request = $this->getUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUniqueWeaponHistory'
     *
     * @param  int $characterId The id of the character to retrieve. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUniqueWeaponHistoryRequest($characterId, $destinyMembershipId, $membershipType)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getUniqueWeaponHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendor
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20042
     */
    public function getVendor($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        list($response) = $this->getVendorWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);
        return $response;
    }

    /**
     * Operation getVendorWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20042, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        $request = $this->getVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20042' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20042', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20042';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorAsync($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        return $this->getVendorAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20042';
        $request = $this->getVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendor'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $vendorHash The Hash identifier of the Vendor to be returned. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorRequest($characterId, $destinyMembershipId, $membershipType, $vendorHash, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendor'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getVendor'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendor'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getVendor'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendors
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20041
     */
    public function getVendors($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        list($response) = $this->getVendorsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components);
        return $response;
    }

    /**
     * Operation getVendorsWithHttpInfo
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorsWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $request = $this->getVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20041';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorsAsync
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorsAsync($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        return $this->getVendorsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorsAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20041';
        $request = $this->getVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendors'
     *
     * @param  int $characterId The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destinyMembershipId Destiny membership ID of another user. You may be denied. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type. (required)
     * @param  \Bungie\Model\Destiny\DestinyComponentType[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorsRequest($characterId, $destinyMembershipId, $membershipType, $components = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendors'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getVendors'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendors'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertSocketPlug
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest destinyInsertPlugsActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20045
     */
    public function insertSocketPlug($destinyInsertPlugsActionRequest)
    {
        list($response) = $this->insertSocketPlugWithHttpInfo($destinyInsertPlugsActionRequest);
        return $response;
    }

    /**
     * Operation insertSocketPlugWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20045, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertSocketPlugWithHttpInfo($destinyInsertPlugsActionRequest)
    {
        $request = $this->insertSocketPlugRequest($destinyInsertPlugsActionRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20045' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20045', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20045';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20045',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertSocketPlugAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSocketPlugAsync($destinyInsertPlugsActionRequest)
    {
        return $this->insertSocketPlugAsyncWithHttpInfo($destinyInsertPlugsActionRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertSocketPlugAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSocketPlugAsyncWithHttpInfo($destinyInsertPlugsActionRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20045';
        $request = $this->insertSocketPlugRequest($destinyInsertPlugsActionRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertSocketPlug'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertSocketPlugRequest($destinyInsertPlugsActionRequest)
    {
        // verify the required parameter 'destinyInsertPlugsActionRequest' is set
        if ($destinyInsertPlugsActionRequest === null || (is_array($destinyInsertPlugsActionRequest) && count($destinyInsertPlugsActionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyInsertPlugsActionRequest when calling insertSocketPlug'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/InsertSocketPlug/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyInsertPlugsActionRequest)) {
            $_tempBody = $destinyInsertPlugsActionRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullFromPostmaster
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyPostmasterTransferRequest $destinyPostmasterTransferRequest destinyPostmasterTransferRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function pullFromPostmaster($destinyPostmasterTransferRequest)
    {
        list($response) = $this->pullFromPostmasterWithHttpInfo($destinyPostmasterTransferRequest);
        return $response;
    }

    /**
     * Operation pullFromPostmasterWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyPostmasterTransferRequest $destinyPostmasterTransferRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function pullFromPostmasterWithHttpInfo($destinyPostmasterTransferRequest)
    {
        $request = $this->pullFromPostmasterRequest($destinyPostmasterTransferRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullFromPostmasterAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyPostmasterTransferRequest $destinyPostmasterTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullFromPostmasterAsync($destinyPostmasterTransferRequest)
    {
        return $this->pullFromPostmasterAsyncWithHttpInfo($destinyPostmasterTransferRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullFromPostmasterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyPostmasterTransferRequest $destinyPostmasterTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullFromPostmasterAsyncWithHttpInfo($destinyPostmasterTransferRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->pullFromPostmasterRequest($destinyPostmasterTransferRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullFromPostmaster'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyPostmasterTransferRequest $destinyPostmasterTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullFromPostmasterRequest($destinyPostmasterTransferRequest)
    {
        // verify the required parameter 'destinyPostmasterTransferRequest' is set
        if ($destinyPostmasterTransferRequest === null || (is_array($destinyPostmasterTransferRequest) && count($destinyPostmasterTransferRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyPostmasterTransferRequest when calling pullFromPostmaster'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/PullFromPostmaster/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyPostmasterTransferRequest)) {
            $_tempBody = $destinyPostmasterTransferRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportOffensivePostGameCarnageReportPlayer
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     * @param  \Bungie\Model\Destiny\Reporting\Requests\DestinyReportOffensePgcrRequest $destinyReportOffensePgcrRequest destinyReportOffensePgcrRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function reportOffensivePostGameCarnageReportPlayer($activityId, $destinyReportOffensePgcrRequest)
    {
        list($response) = $this->reportOffensivePostGameCarnageReportPlayerWithHttpInfo($activityId, $destinyReportOffensePgcrRequest);
        return $response;
    }

    /**
     * Operation reportOffensivePostGameCarnageReportPlayerWithHttpInfo
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     * @param  \Bungie\Model\Destiny\Reporting\Requests\DestinyReportOffensePgcrRequest $destinyReportOffensePgcrRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportOffensivePostGameCarnageReportPlayerWithHttpInfo($activityId, $destinyReportOffensePgcrRequest)
    {
        $request = $this->reportOffensivePostGameCarnageReportPlayerRequest($activityId, $destinyReportOffensePgcrRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reportOffensivePostGameCarnageReportPlayerAsync
     *
     * 
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     * @param  \Bungie\Model\Destiny\Reporting\Requests\DestinyReportOffensePgcrRequest $destinyReportOffensePgcrRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOffensivePostGameCarnageReportPlayerAsync($activityId, $destinyReportOffensePgcrRequest)
    {
        return $this->reportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activityId, $destinyReportOffensePgcrRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     * @param  \Bungie\Model\Destiny\Reporting\Requests\DestinyReportOffensePgcrRequest $destinyReportOffensePgcrRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activityId, $destinyReportOffensePgcrRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->reportOffensivePostGameCarnageReportPlayerRequest($activityId, $destinyReportOffensePgcrRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportOffensivePostGameCarnageReportPlayer'
     *
     * @param  int $activityId The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     * @param  \Bungie\Model\Destiny\Reporting\Requests\DestinyReportOffensePgcrRequest $destinyReportOffensePgcrRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportOffensivePostGameCarnageReportPlayerRequest($activityId, $destinyReportOffensePgcrRequest)
    {
        // verify the required parameter 'activityId' is set
        if ($activityId === null || (is_array($activityId) && count($activityId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activityId when calling reportOffensivePostGameCarnageReportPlayer'
            );
        }
        // verify the required parameter 'destinyReportOffensePgcrRequest' is set
        if ($destinyReportOffensePgcrRequest === null || (is_array($destinyReportOffensePgcrRequest) && count($destinyReportOffensePgcrRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyReportOffensePgcrRequest when calling reportOffensivePostGameCarnageReportPlayer'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($activityId !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activityId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($destinyReportOffensePgcrRequest)) {
            $_tempBody = $destinyReportOffensePgcrRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchDestinyEntities
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20050
     */
    public function searchDestinyEntities($searchTerm, $type, $page = null)
    {
        list($response) = $this->searchDestinyEntitiesWithHttpInfo($searchTerm, $type, $page);
        return $response;
    }

    /**
     * Operation searchDestinyEntitiesWithHttpInfo
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchDestinyEntitiesWithHttpInfo($searchTerm, $type, $page = null)
    {
        $request = $this->searchDestinyEntitiesRequest($searchTerm, $type, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchDestinyEntitiesAsync
     *
     * 
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyEntitiesAsync($searchTerm, $type, $page = null)
    {
        return $this->searchDestinyEntitiesAsyncWithHttpInfo($searchTerm, $type, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchDestinyEntitiesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyEntitiesAsyncWithHttpInfo($searchTerm, $type, $page = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20050';
        $request = $this->searchDestinyEntitiesRequest($searchTerm, $type, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchDestinyEntities'
     *
     * @param  string $searchTerm The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchDestinyEntitiesRequest($searchTerm, $type, $page = null)
    {
        // verify the required parameter 'searchTerm' is set
        if ($searchTerm === null || (is_array($searchTerm) && count($searchTerm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchTerm when calling searchDestinyEntities'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling searchDestinyEntities'
            );
        }

        $resourcePath = '/Destiny2/Armory/Search/{type}/{searchTerm}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }

        // path params
        if ($searchTerm !== null) {
            $resourcePath = str_replace(
                '{' . 'searchTerm' . '}',
                ObjectSerializer::toPathValue($searchTerm),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchDestinyPlayer
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20035
     */
    public function searchDestinyPlayer($displayName, $membershipType)
    {
        list($response) = $this->searchDestinyPlayerWithHttpInfo($displayName, $membershipType);
        return $response;
    }

    /**
     * Operation searchDestinyPlayerWithHttpInfo
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchDestinyPlayerWithHttpInfo($displayName, $membershipType)
    {
        $request = $this->searchDestinyPlayerRequest($displayName, $membershipType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20035' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20035', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20035';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchDestinyPlayerAsync
     *
     * 
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyPlayerAsync($displayName, $membershipType)
    {
        return $this->searchDestinyPlayerAsyncWithHttpInfo($displayName, $membershipType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchDestinyPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyPlayerAsyncWithHttpInfo($displayName, $membershipType)
    {
        $returnType = '\Bungie\Model\InlineResponse20035';
        $request = $this->searchDestinyPlayerRequest($displayName, $membershipType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchDestinyPlayer'
     *
     * @param  string $displayName The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  \Bungie\Model\BungieMembershipType $membershipType A valid non-BungieNet membership type, or All. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchDestinyPlayerRequest($displayName, $membershipType)
    {
        // verify the required parameter 'displayName' is set
        if ($displayName === null || (is_array($displayName) && count($displayName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $displayName when calling searchDestinyPlayer'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling searchDestinyPlayer'
            );
        }

        $resourcePath = '/Destiny2/SearchDestinyPlayer/{membershipType}/{displayName}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($displayName !== null) {
            $resourcePath = str_replace(
                '{' . 'displayName' . '}',
                ObjectSerializer::toPathValue($displayName),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setItemLockState
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemStateRequest $destinyItemStateRequest destinyItemStateRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function setItemLockState($destinyItemStateRequest)
    {
        list($response) = $this->setItemLockStateWithHttpInfo($destinyItemStateRequest);
        return $response;
    }

    /**
     * Operation setItemLockStateWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemStateRequest $destinyItemStateRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function setItemLockStateWithHttpInfo($destinyItemStateRequest)
    {
        $request = $this->setItemLockStateRequest($destinyItemStateRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setItemLockStateAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemStateRequest $destinyItemStateRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemLockStateAsync($destinyItemStateRequest)
    {
        return $this->setItemLockStateAsyncWithHttpInfo($destinyItemStateRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setItemLockStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemStateRequest $destinyItemStateRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemLockStateAsyncWithHttpInfo($destinyItemStateRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->setItemLockStateRequest($destinyItemStateRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setItemLockState'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyItemStateRequest $destinyItemStateRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setItemLockStateRequest($destinyItemStateRequest)
    {
        // verify the required parameter 'destinyItemStateRequest' is set
        if ($destinyItemStateRequest === null || (is_array($destinyItemStateRequest) && count($destinyItemStateRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyItemStateRequest when calling setItemLockState'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/SetLockState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyItemStateRequest)) {
            $_tempBody = $destinyItemStateRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferItem
     *
     * @param  \Bungie\Model\Destiny\Requests\DestinyItemTransferRequest $destinyItemTransferRequest destinyItemTransferRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20019
     */
    public function transferItem($destinyItemTransferRequest)
    {
        list($response) = $this->transferItemWithHttpInfo($destinyItemTransferRequest);
        return $response;
    }

    /**
     * Operation transferItemWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\DestinyItemTransferRequest $destinyItemTransferRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferItemWithHttpInfo($destinyItemTransferRequest)
    {
        $request = $this->transferItemRequest($destinyItemTransferRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferItemAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\DestinyItemTransferRequest $destinyItemTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferItemAsync($destinyItemTransferRequest)
    {
        return $this->transferItemAsyncWithHttpInfo($destinyItemTransferRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\DestinyItemTransferRequest $destinyItemTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferItemAsyncWithHttpInfo($destinyItemTransferRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20019';
        $request = $this->transferItemRequest($destinyItemTransferRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferItem'
     *
     * @param  \Bungie\Model\Destiny\Requests\DestinyItemTransferRequest $destinyItemTransferRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function transferItemRequest($destinyItemTransferRequest)
    {
        // verify the required parameter 'destinyItemTransferRequest' is set
        if ($destinyItemTransferRequest === null || (is_array($destinyItemTransferRequest) && count($destinyItemTransferRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyItemTransferRequest when calling transferItem'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/TransferItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyItemTransferRequest)) {
            $_tempBody = $destinyItemTransferRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
