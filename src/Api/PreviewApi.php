<?php
/**
 * PreviewApi
 * PHP version 5
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.8.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bungie\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bungie\ApiException;
use Bungie\Configuration;
use Bungie\HeaderSelector;
use Bungie\ObjectSerializer;

/**
 * PreviewApi Class Doc Comment
 *
 * @category Class
 * @package  Bungie
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PreviewApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getClanAggregateStats
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20050
     */
    public function getClanAggregateStats($groupId, $modes = null)
    {
        list($response) = $this->getClanAggregateStatsWithHttpInfo($groupId, $modes);
        return $response;
    }

    /**
     * Operation getClanAggregateStatsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanAggregateStatsWithHttpInfo($groupId, $modes = null)
    {
        $request = $this->getClanAggregateStatsRequest($groupId, $modes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanAggregateStatsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanAggregateStatsAsync($groupId, $modes = null)
    {
        return $this->getClanAggregateStatsAsyncWithHttpInfo($groupId, $modes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanAggregateStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanAggregateStatsAsyncWithHttpInfo($groupId, $modes = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20050';
        $request = $this->getClanAggregateStatsRequest($groupId, $modes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanAggregateStats'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanAggregateStatsRequest($groupId, $modes = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getClanAggregateStats'
            );
        }

        $resourcePath = '/Destiny2/Stats/AggregateClanStats/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClanLeaderboards
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20049
     */
    public function getClanLeaderboards($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getClanLeaderboardsWithHttpInfo($groupId, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getClanLeaderboardsWithHttpInfo
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanLeaderboardsWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsync($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsyncWithHttpInfo($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20049';
        $request = $this->getClanLeaderboardsRequest($groupId, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanLeaderboards'
     *
     * @param  int $groupId Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanLeaderboardsRequest($groupId, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/Clans/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboards
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20049
     */
    public function getLeaderboards($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getLeaderboardsWithHttpInfo
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsAsync
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsync($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsyncWithHttpInfo($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20049';
        $request = $this->getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboards'
     *
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsRequest($destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getLeaderboards'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboardsForCharacter
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20049
     */
    public function getLeaderboardsForCharacter($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->getLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation getLeaderboardsForCharacterWithHttpInfo
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsForCharacterWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsync($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->getLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsyncWithHttpInfo($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20049';
        $request = $this->getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboardsForCharacter'
     *
     * @param  int $characterId The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destinyMembershipId The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membershipType A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsForCharacterRequest($characterId, $destinyMembershipId, $membershipType, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }
        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }

        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicVendors
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20043
     */
    public function getPublicVendors($components = null)
    {
        list($response) = $this->getPublicVendorsWithHttpInfo($components);
        return $response;
    }

    /**
     * Operation getPublicVendorsWithHttpInfo
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicVendorsWithHttpInfo($components = null)
    {
        $request = $this->getPublicVendorsRequest($components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicVendorsAsync
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorsAsync($components = null)
    {
        return $this->getPublicVendorsAsyncWithHttpInfo($components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorsAsyncWithHttpInfo($components = null)
    {
        $returnType = '\Bungie\Model\InlineResponse20043';
        $request = $this->getPublicVendorsRequest($components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicVendors'
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicVendorsRequest($components = null)
    {

        $resourcePath = '/Destiny2//Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'multi', false);
        }
        if ($components !== null) {
            $queryParams['components'] = ObjectSerializer::toQueryValue($components);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertSocketPlug
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest destinyInsertPlugsActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\Model\InlineResponse20046
     */
    public function insertSocketPlug($destinyInsertPlugsActionRequest)
    {
        list($response) = $this->insertSocketPlugWithHttpInfo($destinyInsertPlugsActionRequest);
        return $response;
    }

    /**
     * Operation insertSocketPlugWithHttpInfo
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \Bungie\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertSocketPlugWithHttpInfo($destinyInsertPlugsActionRequest)
    {
        $request = $this->insertSocketPlugRequest($destinyInsertPlugsActionRequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertSocketPlugAsync
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSocketPlugAsync($destinyInsertPlugsActionRequest)
    {
        return $this->insertSocketPlugAsyncWithHttpInfo($destinyInsertPlugsActionRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertSocketPlugAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSocketPlugAsyncWithHttpInfo($destinyInsertPlugsActionRequest)
    {
        $returnType = '\Bungie\Model\InlineResponse20046';
        $request = $this->insertSocketPlugRequest($destinyInsertPlugsActionRequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertSocketPlug'
     *
     * @param  \Bungie\Model\Destiny\Requests\Actions\DestinyInsertPlugsActionRequest $destinyInsertPlugsActionRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertSocketPlugRequest($destinyInsertPlugsActionRequest)
    {
        // verify the required parameter 'destinyInsertPlugsActionRequest' is set
        if ($destinyInsertPlugsActionRequest === null || (is_array($destinyInsertPlugsActionRequest) && count($destinyInsertPlugsActionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyInsertPlugsActionRequest when calling insertSocketPlug'
            );
        }

        $resourcePath = '/Destiny2/Actions/Items/InsertSocketPlug/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($destinyInsertPlugsActionRequest)) {
            $_tempBody = $destinyInsertPlugsActionRequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
